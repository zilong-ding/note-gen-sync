# 项目背景

智能对话系统（如聊天机器人、智能语音助手）、搜索引擎和垂直领域问答系统的核心。

不是闲聊助手，理解查询意图，并将其转化为计算机可以精确处理和执行的结构化数据。

## 输入和输出

原始输入（text）: “查询许昌到中山的汽车。”

语义解析输出（Structured Data）:

```

intent： 意图 （用户提问的类型）
QUERY（查询）、BOOK（预订）、CANCEL（取消）、COMPARE（对比）
domain： 领域
slots：槽位（实体）
{ “Dest”: “中山”, “Src”: “许昌” }
```

结构化查询

```

SELECT * FROM bus_schedule WHERE src = '许昌' AND dest = '中山';
```

组织为自然语言 -》 输出

## 项目产出（一个可部署、可调用、高准确率的XX领域助手）

智能对话助手（智能体）接收用户的自然语言输入，并输出结构化的、机器可读的数据，以便后续系统执行精确的查询。

## 项目技术路线

- BERT（微调）：意图识别 + 实体识别
- GPT（提示词、后序可以考虑微调）：大模型识别意图 + 实体

## 项目时间轴

1M


# 技术方案

## 业务逻辑

![2025-09-27_10-03.jpg](https://cdn.jsdelivr.net/gh/zilong-ding/note-gen-image-sync@main/f88f016d-2215-4b43-a90f-9a28878703cc.jpeg)


## 实施方案

## ✅ 增强版实施方案（总周期：3~4 周）

### 阶段 1：数据构建与验证（7天）✅ **关键！决定上限**


| 任务                | 详细说明                                                                                                                                     | 交付物                                               | 风险控制         |
| ------------------- | -------------------------------------------------------------------------------------------------------------------------------------------- | ---------------------------------------------------- | ---------------- |
| **1.1 定义 Schema** | 明确 4 意图 + 8 槽位<br />（含多值`VehicleType`），<br />制定 BIO 标签体系                                                                   | `schema.json`（含 intent/slot 定义）                 | 避免后期槽位变更 |
| **1.2 数据采集**    | - 真实用户日志（如有）<br>- <br />模板生成<br />（“查{Src}到{Dest}<br />的{Vehicle}”）<br>- <br />人工编写（覆盖口语、<br />错别字、省略） | 原始语料库<br />（≥3000 条）                        | 覆盖长尾表达     |
| **1.3 标注与质检**  | - 使用 Label Studio 标注<br>- <br />按字切分 + <br />BIO 标注<br>- <br />双人校验（Kappa ≥ 0.8）                                            | 标注数据集<br />（JSONL 格式）                       | 避免标注噪声     |
| **1.4 数据划分**    | Train: 70%, Dev: 15%, <br />Test: 15%（按意图分层抽样）                                                                                      | `train.jsonl`, <br />`dev.jsonl`, <br />`test.jsonl` | 确保各意图均衡   |

> 📌 **建议**：优先保证 **BOOK / QUERY** 数据质量（高频意图），COMPARE / CANCEL 可稍少。

---

### 阶段 2：模型选型与训练（10~12天）✅ **核心：验证哪种方案性价比最高**

#### 技术路线对比（按优先级排序）


| 方案                                                            | 优点                                                                     | 缺点                                                    | 适用场景                         | 推荐指数   |
| --------------------------------------------------------------- | ------------------------------------------------------------------------ | ------------------------------------------------------- | -------------------------------- | ---------- |
| **A. 统一 BERT（多任务）**<br>（你已实现）                      | - 共享语义，准确率高<br>- 单模型，<br />部署简单<br>- 训练快（1~2 小时） | 需标注数据                                              | **首选！** 数据 ≥1000 条        | ⭐⭐⭐⭐⭐ |
| **B. 双 BERT（独立模型）**                                      | 意图/槽位解耦，调试灵活                                                  | 模型大、延迟高、数据利用率低                            | 不推荐（除非意图差异极大）       | ⭐⭐       |
| **C. 大模型 Prompt（Zero/Few-shot）**<br>（如 ChatGLM3 / Qwen） | 无需训练，快速验证                                                       | - 成本高（API/推理）<br>- 输出不稳定<br>- 难结构化      | 仅用于**基线对比**               | ⭐⭐       |
| **D. 大模型微调（LoRA）**<br>（如 ChatGLM3-6B + LoRA）          | 强泛化，支持复杂表达                                                     | - 显存要求高（≥24G）<br>- 训练慢（天级）<br>- 部署复杂 | 数据极少（<500）或需支持多轮对话 | ⭐⭐⭐     |

#### ✅ 推荐执行顺序：

1. **先跑通方案 A（统一 BERT）** → 快速得到 baseline（第 3 天出结果）
2. **用方案 C（大模型 Prompt）做对比实验** → 验证数据质量上限
3. **若 A 效果达标（Intent Acc > 92%, Slot F1 > 88%），则放弃 C/D**
4. **仅当 A 效果差且数据极少时，考虑 D（大模型微调）**

#### 训练计划（以方案 A 为主）：


| 天数     | 任务                                              |
| -------- | ------------------------------------------------- |
| 第1天    | 搭建统一 BERT 多任务代码（使用你修正后的模型）    |
| 第2天    | 数据预处理（tokenizer 对齐、padding、label 映射） |
| 第3天    | 训练 + 在 dev 集调参（lr=2e-5, epoch=5）          |
| 第4天    | 测试集评估（Intent Acc, Slot F1, 联合准确率）     |
| 第5天    | 错误分析（bad case 归因：数据？模型？）           |
| 第6-7天  | 迭代：补充数据 or 调整模型（如加 CRF 层）         |
| 第8-10天 | 尝试大模型 Prompt 基线（可选）                    |

> 📊 **评估指标必须包含**：
>
> - 意图准确率（Intent Accuracy）
> - 槽位 F1-score（按实体类型）
> - **端到端准确率**（Intent 正确 **且** 所有槽位正确）

---

### 阶段 3：业务系统构建（7~10天）✅ **让模型真正可用**


| 模块               | 关键任务                                                                                                                              | 技术栈建议                           |
| ------------------ | ------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------ |
| **3.1 后处理引擎** | - BIO → 实体合并<br>- 多值槽位聚合（VehicleType）<br>- 实体归一化（“高铁”→“train”）<br>- 日期标准化（“明天”→“2025-09-28”） | Python +`cn2an` + `chinese-calendar` |
| **3.2 查询生成器** | 根据 intent + slots 生成：<br>- SQL 模板<br>- 或结构化 Query 对象（推荐）                                                             | Jinja2 模板 / 策略模式               |
| **3.3 API 服务**   | 提供 HTTP 接口：<br>`POST /parse {text} → {intent, slots, query}`                                                                    | FastAPI + Uvicorn                    |
| **3.4 部署**       | - Docker 容器化<br>- 模型量化（可选）<br>- 压测（QPS ≥ 50）                                                                          | Docker + Nginx + Prometheus          |
| **3.5 监控与日志** | 记录输入/输出、延迟、错误率                                                                                                           | ELK / 自定义日志                     |

#### 示例 API 响应：

```json
{
  "intent": "BOOK",
  "slots": {
    "Src": "许昌",
    "Dest": "中山",
    "Date": "2025-09-28",
    "PassengerCount": 1
  },
  "query": {
    "action": "create_booking",
    "params": { ... }
  }
}
```

---

## 🚦 风险与应对策略


| 风险                             | 应对措施                                                                      |
| -------------------------------- | ----------------------------------------------------------------------------- |
| **数据不足导致效果差**           | - 启动模板生成 + 回译增强<br>- 用大模型生成伪标签（需人工校验）               |
| **多值槽位识别不准**             | - 在后处理中加入规则兜底（如“和”“或”分割）<br>- 单独评估 `VehicleType` F1 |
| **线上延迟高**                   | - 模型导出为 ONNX<br>- 使用 CPU 优化（Intel OpenVINO）                        |
| **意图混淆（QUERY vs COMPARE）** | - 在训练数据中增加对比样本<br>- 联合准确率作为核心指标                        |

---

## 📅 最终交付物清单


| 类别     | 交付物                                                           |
| -------- | ---------------------------------------------------------------- |
| **数据** | 标注数据集（含 train/dev/test）、schema 定义                     |
| **模型** | 训练好的统一 BERT 模型（.bin + config）、评估报告                |
| **代码** | - 模型训练脚本<br>- 后处理模块<br>- FastAPI 服务<br>- Dockerfile |
| **文档** | - API 接口文档<br>- 部署手册<br>- 错误码说明                     |

---

## ✅ 总结：你的方案如何优化？


| 你的原计划                              | 建议增强点                                                            |
| --------------------------------------- | --------------------------------------------------------------------- |
| “构建数据集，7天”                     | → 细化为**采集→标注→质检→划分** 四步，<br />强调 schema 先行      |
| “模型训练：双BERT/统一BERT/大模型...” | →**明确优先级**：统一 BERT 为主，<br />大模型仅作基线                |
| “业务构建”                            | → 拆解为**后处理→查询生成→API→部署** 四模块，<br />强调结构化输出 |

> 💡 **核心原则**：
> **小步快跑，数据驱动，先跑通再优化**。
> 用 **统一 BERT 多任务模型** 作为主线，7 天内出第一个可测版本，再迭代。



# 数据集构建

```python
# entities.py
CITIES = [
    "北京", "上海", "广州", "深圳", "杭州", "成都", "武汉", "西安", "南京", "天津",
    "重庆", "苏州", "郑州", "长沙", "青岛", "沈阳", "大连", "宁波", "厦门", "许昌",
    "中山", "佛山", "东莞", "珠海", "惠州", "江门", "肇庆", "汕头", "潮州", "揭阳"
]

VEHICLES = {
    "汽车": "bus",
    "大巴": "bus",
    "班车": "bus",
    "火车": "train",
    "高铁": "train",
    "动车": "train",
    "飞机": "plane",
    "航班": "plane"
}

DATES = ["今天", "明天", "后天", "周一", "周二", "周三", "周四", "周五", "周六", "周日", "下周一"]
TIMES = ["上午", "下午", "晚上", "早上", "中午", "9点", "10点", "15点", "18点"]
SEAT_TYPES = ["一等座", "二等座", "商务座", "硬座", "软座", "卧铺"]
```

```python
# templates.py
TEMPLATES = {
    "QUERY": [
        "查一下{src}到{dest}的{vehicle}。",
        "我想看看{src}去{dest}有什么{vehicle}。",
        "从{src}到{dest}的{vehicle}有哪些？",
        "有没有{src}到{dest}的{vehicle}？",
        "查询{date}{src}到{dest}的{vehicle}。",
        "{src}到{dest}的{vehicle}什么时候发车？",
        "帮我查{src}到{dest}的{vehicle}票。",
        "看看{src}去{dest}的{vehicle}。",
        "我想知道{src}到{dest}的{vehicle}信息。",
        "查{src}到{dest}的{vehicle}班次。"
    ],
    "BOOK": [
        "我想订一张{date}{src}到{dest}的{vehicle}票。",
        "帮我预订{date}{time}{src}到{dest}的{vehicle}。",
        "订票：{src}到{dest}，{date}，{vehicle}。",
        "我要买{date}从{src}到{dest}的{vehicle}票，{passenger_count}个人。",
        "预订{src}到{dest}的{vehicle}，{date}出发，{seat_type}。",
        "帮我订{date}{src}去{dest}的{vehicle}，{passenger_count}张。",
        "我想订{date}{time}从{src}到{dest}的{vehicle}，{seat_type}。",
        "订一张{src}到{dest}的{vehicle}票，{date}，{passenger_count}人。",
        "我要预订{date}从{src}到{dest}的{vehicle}，{seat_type}。",
        "帮我订{src}到{dest}的{vehicle}，{date}，{passenger_count}个人。"
    ],
    "COMPARE": [
        "比较一下{src}到{dest}坐{vehicle1}和{vehicle2}哪个快？",
        "{src}到{dest}，{vehicle1}和{vehicle2}的价格对比。",
        "帮我对比{src}到{dest}的{vehicle1}和{vehicle2}。",
        "{src}去{dest}，{vehicle1}跟{vehicle2}哪个便宜？",
        "比较{src}到{dest}的{vehicle1}、{vehicle2}和{vehicle3}的时间。",
        "我想知道{src}到{dest}坐{vehicle1}和{vehicle2}有什么区别。",
        "对比一下{src}到{dest}的{vehicle1}和{vehicle2}的票价。",
        "{src}到{dest}，{vehicle1}和{vehicle2}哪个更方便？",
        "帮我看看{src}到{dest}的{vehicle1}和{vehicle2}怎么选。",
        "比较{date}{src}到{dest}的{vehicle1}和{vehicle2}。"
    ],
    "CANCEL": [
        "取消订单{booking_id}。",
        "我想取消{src}到{dest}的订单，{date}的。",
        "帮我取消预订：{src}到{dest}，{date}。",
        "取消我的{vehicle}票，{src}到{dest}，{date}。",
        "我要退掉{date}从{src}到{dest}的{vehicle}票。",
        "取消订单，{src}到{dest}，{date}。",
        "请帮我取消{booking_id}这个订单。",
        "我想退订{src}到{dest}的{vehicle}，{date}。",
        "取消我的行程：{src}到{dest}，{date}。",
        "退掉{date}{src}到{dest}的{vehicle}票。"
    ]
}
```

```python
# generate_data.py
import random
import json
from itertools import product
from entities import CITIES, VEHICLES, DATES, TIMES, SEAT_TYPES

# 加载模板
from templates import TEMPLATES

def get_random_booking_id():
    return f"BK{random.randint(100000, 999999)}"

def bio_tag(text, entities):
    """为文本生成 BIO 标签"""
    tokens = list(text)
    labels = ["O"] * len(tokens)
  
    for slot_name, value in entities.items():
        if not value:
            continue
        # 处理多值槽位（如 VehicleTypes）
        values = value if isinstance(value, list) else [value]
        for v in values:
            start = text.find(v)
            while start != -1:
                labels[start] = f"B-{slot_name}"
                for i in range(1, len(v)):
                    if start + i < len(labels):
                        labels[start + i] = f"I-{slot_name}"
                start = text.find(v, start + 1)
    return labels

def generate_samples():
    samples = []
    intent_counts = {"QUERY": 600, "BOOK": 600, "COMPARE": 400, "CANCEL": 400}
  
    for intent, count in intent_counts.items():
        for _ in range(count):
            # 随机选实体
            src = random.choice(CITIES)
            dest = random.choice([c for c in CITIES if c != src])
            vehicle = random.choice(list(VEHICLES.keys()))
            date = random.choice(DATES)
            time = random.choice(TIMES)
            passenger = random.randint(1, 5)
            seat = random.choice(SEAT_TYPES)
            booking_id = get_random_booking_id()
        
            # 为 COMPARE 选多个交通工具
            if intent == "COMPARE":
                vehicles = random.sample(list(VEHICLES.keys()), k=min(2, len(VEHICLES)))
                template = random.choice(TEMPLATES[intent])
                # 替换 {vehicle1}, {vehicle2}
                text = template.format(
                    src=src, dest=dest, date=date,
                    vehicle1=vehicles[0],
                    vehicle2=vehicles[1] if len(vehicles) > 1 else vehicles[0],
                    vehicle3=random.choice(VEHICLES.keys())  # 用于三选项模板
                )
                slots = {
                    "Src": src,
                    "Dest": dest,
                    "Date": date if "date" in template else None,
                    "VehicleTypes": vehicles
                }
            elif intent == "CANCEL":
                if random.random() > 0.5:
                    text = random.choice(TEMPLATES[intent]).format(
                        booking_id=booking_id
                    )
                    slots = {"BookingID": booking_id}
                else:
                    text = random.choice(TEMPLATES[intent]).format(
                        src=src, dest=dest, date=date, vehicle=vehicle
                    )
                    slots = {"Src": src, "Dest": dest, "Date": date}
            else:
                template = random.choice(TEMPLATES[intent])
                text = template.format(
                    src=src, dest=dest, vehicle=vehicle,
                    date=date, time=time,
                    passenger_count=passenger, seat_type=seat
                )
                slots = {
                    "Src": src,
                    "Dest": dest,
                    "VehicleType": vehicle,
                    "Date": date if "date" in template.lower() else None,
                    "Time": time if "time" in template.lower() else None,
                }
                if intent == "BOOK":
                    slots.update({
                        "PassengerCount": str(passenger),
                        "SeatType": seat
                    })
        
            # 清理 None 值
            slots = {k: v for k, v in slots.items() if v is not None}
        
            # 生成 BIO 标签
            bio_labels = bio_tag(text, slots)
        
            samples.append({
                "text": text,
                "intent": intent,
                "slots_bio": bio_labels
            })
  
    return samples

if __name__ == "__main__":
    samples = generate_samples()
    print(f"生成 {len(samples)} 条样本")
  
    # 保存为 JSONL
    with open("train_data.jsonl", "w", encoding="utf-8") as f:
        for sample in samples:
            f.write(json.dumps(sample, ensure_ascii=False) + "\n")
  
    # 打印示例
    print("\n示例：")
    for i in range(3):
        print(samples[i])
```
